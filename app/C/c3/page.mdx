import QuizQuestion from '../../../components/QuizQuestion';

# Tablice w języku C

Tablica to **ciąg elementów tego samego typu ułożonych w pamięci kolejno, bez przerw**.
Elementy tablicy mają:

- **wspólną nazwę**,
- **ten sam typ**,
- są dostępne przez **indeks**, zaczynający się od **0**.

Tablice są fundamentem pracy w C — są szybkie, przewidywalne i bardzo niskopoziomowe.

---

## Deklaracja tablicy

```c
typ nazwa[ROZMIAR];
````

### Przykład: tablica liczb całkowitych

```c
int liczby[5];
```

To oznacza:

* w pamięci powstaje 5 kolejnych `int`,
* dostęp do elementów: `liczby[0]`, ..., `liczby[4]`,
* indeks **zawsze zaczyna się od 0**, nie od 1.

---

## Inicjalizacja tablicy

### 1) Inicjalizacja pełna

```c
int tab[5] = {1, 2, 3, 4, 5};
```

### 2) Inicjalizacja częściowa

Brakujące elementy są wypełniane **zerami**:

```c
int tab[5] = {1, 2};  // {1, 2, 0, 0, 0}
```

### 3) Automatyczne obliczenie rozmiaru

```c
int tab[] = {4, 8, 15, 16, 23, 42};
```

---

## Dostęp do elementów

```c
int x = tab[0];   // pierwszy element
tab[3] = 99;      // zmiana wartości
```

> [!NOTE]
>
> **Standard C nie sprawdza indeksów tablicy.**
> `tab[9999] = 7;` *skompiluje się*, ale prowadzi do nadpisania pamięci → błąd krytyczny.

---

## Iteracja po tablicy

```c
int t[5] = {1,2,3,4,5};

for (int i = 0; i < 5; i++)
    printf("%d\n", t[i]);
```

Lepsza opcja — obliczanie rozmiaru tablicy:

```c
int roz = sizeof(t) / sizeof(t[0]);
```

### Co oznaczają te wartości?

> [!NOTE]
>
> `sizeof(t)` → liczba **bajtów całej tablicy**
> `sizeof(t[0])` → liczba **bajtów pojedynczego elementu**
>
> Dzieląc te wartości dostajemy **liczbę elementów tablicy**, niezależnie od typu i rozmiaru elementu.
>
> To działa jedynie dla **tablic statycznych (lokalnych/globalnych)**.
> Dla wskaźników nie działa — o tym w dziale o wskaźnikach.

---

## Tablice typów innych niż `int`

Tablice mogą przechowywać dowolne typy:

### `double`

```c
double pomiary[3] = {1.1, 2.5, 3.14};
```

### `char`

```c
char znaki[4] = {'A', 'B', 'C', 'D'};
```

### `_Bool`

```c
_Bool flags[3] = {1, 0, 1};
```

podobnie dla innych typów zmiennych

## Tablice wielowymiarowe

Najczęściej tablice 2D:

```c
int mat[3][4];
```

To macierz **3×4** (3 wiersze, 4 kolumny).

### Inicjalizacja:

```c
int mat[2][3] = {
    {1, 2, 3},
    {4, 5, 6}
};
```

### Dostęp:

```c
printf("%d\n", mat[1][2]);  // 6
```

---

## Tablica 2D jako pamięć ciągła — o co chodzi?

Tablica 2D jest fizycznie **jednym dużym blokiem pamięci**.
C nie tworzy tablic tablic — tworzy **ciąg liczb**, ale interpretuje go jak macierz.

### Wizualizacja:

Dla:

```c
int m[2][3] = {
    {1, 2, 3},
    {4, 5, 6}
};
```

W pamięci:

```
[1][2][3][4][5][6]
```

### Co to daje?

* szybki dostęp do elementów,
* możliwość „ręcznego” obliczania indeksów:

```c
m[i][j]  ≡  *(&m[0][0] + i * LICZBA_KOLUMN + j)
```

Ale **nie rób tego na początku nauki** — to przyda się w optymalizacji i programowaniu niskopoziomowym.

---

# Tablice znaków (`char[]`)

To jeden z najważniejszych tematów w całym C.

* **Tablica `char` to nie zawsze napis.**
* Ale **napis zawsze jest tablicą `char` zakończoną `'\0'`**.

---

## Napisy w C — jak działają?

W C **nie ma typu `string`**.
Napis to **ciąg znaków zakończony null-terminatorem `'\0'`**.

### Różnica między `'a'` a `"a"`:

* `'a'` → **pojedynczy znak** (`char`)
* `"a"` → **napis** (`char[2]` → `'a'`, `'\0'`)

> [!NOTE]
>
> Wpisanie tekstu w cudzysłowie:
>
> ```c
> "Ala"
> ```
>
> automatycznie dodaje **`'\0'` na końcu**.
> To zachowanie jest gwarantowane przez standard C.

### Przykład

```c
char s[] = "Ala";
```

W pamięci:

```
'A' 'l' 'a' '\0'
```

---

## Inicjalizacja napisu

### 1) Przez literał (najczęściej)

```c
char s[] = "Hello";
```

Compiler sam oblicza rozmiar (6 znaków: H e l l o \0).

### 2) Ręcznie

```c
char s[6] = {'H', 'E', 'L', 'L', 'O', '\0'};
```

---

## Kluczowa zasada — dodatkowy bajt

Jeśli chcesz przechować **n znaków**, tablica musi mieć **n + 1 bajtów**:

```c
char buf[11];  // dla 10 znaków + '\0'
```

---

## Bezpieczne wczytywanie napisów

### ❌ NIEBEZPIECZNIE

```c
scanf("%s", buf);
```

Może przepełnić bufor.

### ✔️ LEPIEJ

```c
scanf("%19s", buf);  // dla char buf[20]
```

### ✔️ NAJBEZPIECZNIEJ

```c
fgets(buf, sizeof(buf), stdin);
```

> [!NOTE]
>
> `fgets()` wczytuje max `sizeof(buf) - 1` znaków
> i **zawsze** terminator `'\0'`.

---

## Najczęstsze błędy z tablicami znaków

### 1) Za mała tablica

```c
char s[3] = "Ala"; // ❌ potrzeba 4 bajtów
```

### 2) Pisanie poza tablicę

```c
char s[5];
scanf("%s", s); // 100 znaków = katastrofa
```

### 3) Mieszanie tablic i wskaźników

```c
char s[] = "Kot";
char *p = s; // OK
p++;         // przesuwa wskaźnik
```

Więcej o tym w dziale o wskaźnikach.

---

# Quiz — tablice i napisy

<QuizQuestion
  question="Które zdanie o tablicach w C jest prawdziwe?"
  multiple={false}
  options={[
    { id: 'a', text: 'Indeksowanie zaczyna się od 1', correct: false },
    { id: 'b', text: 'Tablica jest ciągłym blokiem pamięci', correct: true },
    { id: 'c', text: 'Tablice mają dynamiczny rozmiar', correct: false },
    { id: 'd', text: 'C sprawdza poprawność indeksów tablicy', correct: false },
  ]}
/>

<QuizQuestion
  question="Ile bajtów musi mieć tablica, która ma przechować 12 znaków napisu?"
  multiple={false}
  options={[
    { id: 'a', text: '12', correct: false },
    { id: 'b', text: '13', correct: true, explanation: 'Musi zmieścić 12 znaków + terminator \\0.' },
    { id: 'c', text: '11', correct: false },
    { id: 'd', text: '24', correct: false },
  ]}
/>

<QuizQuestion
  question='Co przedstawia literał "Kot"?'
  multiple={false}
  options={[
    { id: 'a', text: 'Pojedynczy znak', correct: false },
    { id: 'b', text: 'Napis zakończony \\0', correct: true },
    { id: 'c', text: 'Adres funkcji', correct: false },
    { id: 'd', text: 'Niepoprawną konstrukcję', correct: false },
  ]}
/>

<QuizQuestion
  question="Która forma wczytywania napisów jest najbezpieczniejsza?"
  multiple={false}
  options={[
    { id: 'a', text: 'scanf("%s", buf)', correct: false },
    { id: 'b', text: 'scanf("%19s", buf)', correct: false },
    { id: 'c', text: 'fgets(buf, sizeof(buf), stdin)', correct: true },
    { id: 'd', text: 'gets(buf)', correct: false },
  ]}
/>

<QuizQuestion
  question="Jak wygląda napis 'Ala' w pamięci?"
  multiple={false}
  options={[
    { id: 'a', text: "A l a", correct: false },
    { id: 'b', text: "A l a \\0", correct: true },
    { id: 'c', text: "\\0 A l a", correct: false },
    { id: 'd', text: "A l a ?", correct: false },
  ]}
/>
